from FireApi.connection import Connection
from FireApi.route import Route
from FireApi.request import Request
from FireApi.response import Response
from FireApi.modules import PyModules
from FireApi.server_stats import HTTPLiteStats

from python import Python, PythonObject
import time


struct HTTPLite:
    """'Lite' wrapper for the python socket library with HTTP protocol."""
    var __modules: PyModules
    var __py_socket: PythonObject
    var host_name: PythonObject
    var host_addr: StringLiteral
    var port: Int
    var stats: HTTPLiteStats

    fn __init__(inout self, port: Int, host_addr: StringLiteral = "") raises -> None:
        self.port = port
        self.host_addr = host_addr
        self.stats = HTTPLiteStats()
        self.__modules = PyModules()
        self.host_name = self.__modules.socket.gethostbyname(
            self.__modules.socket.gethostname(),
        )
        self.__py_socket = None
        self.__spinup_socket()
        self.__bind_pySocket()

    fn __bind_pySocket(self) raises -> None:
        """Private funciton that binds the initialized python socket to the given host and port. this runs in __init__()"""
        _ = self.__py_socket.bind((self.host_addr, self.port))

    fn __close_socket(self) raises -> None:
        _ = self.__py_socket.close()

    fn __spinup_socket(inout self) raises -> None:
        self.__py_socket = self.__modules.socket.socket(
            self.__modules.socket.AF_INET,
            self.__modules.socket.SOCK_STREAM,
        )

    fn __print_start[T: Route](self, route: T) raises -> None:
        let fire = "ðŸ”¥ðŸ”¥ðŸ”¥"
        print(fire + " FireApi HTTPLite Service " + fire + "\n")
        print("listening @ " + self.full_addr[T](route) + " ...\n")

    fn __accept_connection(self) raises -> Connection:
        let conn_addr = self.__py_socket.accept()
        return Connection(conn_addr=conn_addr, py=self.__modules.py)

    fn full_addr[T: Route](self, route: T) raises -> String:
        """Returns full address of the HTTPLite server including the routes' endpoint."""
        return "http://" 
            + str(self.host_name) 
            + "/" + self.port 
            + route.get_endpoint()
        
    fn __update_metrics(inout self, et: Float64) -> None:
        """Private function that updates the metrics that enhance logging output."""
        self.stats.update(execution_time=et)

    fn run[T: Route](inout self, route: T, _call: Int = 0) raises -> None:
        """Main funciton that the user calls to begin hosting the HTTPLite server."""
        if not _call:
            self.__print_start[T](route=route)

        _ = self.__py_socket.listen()
        let connection: Connection = self.__accept_connection()
        connection.print_log_connect_message()

        let raw_request = connection.recieve_data()
        let st: Float64 = time.now()
        let response: Response = self.__handle_request[T](
            route=route, connection=connection, _call=_call,
            raw_request=raw_request,
        )

        connection.send_response(response)
        connection.close()

        # print additional response information
        let execution_time: Float64 = (time.now() - st)
        self.__update_metrics(et=execution_time)
        response.print_log_message(
            execution_time=self.stats.most_recent_secs(), 
            raw_request=raw_request,
            symbol="ðŸ”¥" if (execution_time <= self.stats.average_execution_time) else "ðŸ¥¶"
        )

        # go back to listening for requests
        self.run[T](route=route, _call=_call + 1)

    fn __handle_request[
        T: Route
    ](self, route: T, raw_request: String, connection: Connection, _call: Int) raises -> Response:
        """Private function that makes generates a Response object given a Request object."""
        if not raw_request:
            return Response.empty_request_error()

        let request = Request.from_raw(raw_request)
        if not request.is_valid():
            return Response.malformed_request_error()

        let response = route.func(request=request)
        return response
