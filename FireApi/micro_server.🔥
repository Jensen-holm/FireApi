from python import Python, PythonObject
from FireApi.connection import Connection
from FireApi.route import Route
from FireApi.request import Request
from FireApi.response import Response
from FireApi.modules import PyModules
import time


struct HTTPMicro:
    var __modules: PyModules
    var __py_socket: PythonObject
    var __host_name: PythonObject
    var __host_addr: StringLiteral
    var __port: Int

    fn __init__(inout self, host_addr: StringLiteral, port: Int) raises -> None:
        self.__modules = PyModules()
        self.__port = port
        self.__host_addr = host_addr

        self.__host_name = self.__modules.socket.gethostbyname(
            self.__modules.socket.gethostname(),
        )
        self.__py_socket = self.__modules.socket.socket(
            self.__modules.socket.AF_INET,
            self.__modules.socket.SOCK_STREAM,
        )
        self.__bind_pySocket()

    fn __bind_pySocket(self) raises -> None:
        try:
            _ = self.__py_socket.bind((self.__host_addr, self.__port))
        except Exception:
            raise Error("error binding pysocket to hostAddr & port")

    # right now we are never using this function and I wonder if that is bad or not ...
    fn __close_socket(self) raises -> None:
        _ = self.__py_socket.close()

    fn __print_start[T: Route](self, route: T) raises -> None:
        let fire = "ðŸ”¥ðŸ”¥ðŸ”¥"
        let endpoint: String = "http://" + str(
            self.__host_name
        ) + "/" + self.__port + route.get_endpoint()
        print(fire + " FireApi Micro HTTP Service " + fire + "\n")
        print("listening @ " + self.full_addr() + " ...\n")

    fn __accept_connection(self) raises -> Connection:
        let conn_addr = self.__py_socket.accept()
        return Connection(conn_addr=conn_addr, py=self.__modules.py)

    fn full_addr(self) raises -> String:
        return "http://" + str(self.__host_name) + "/" + self.__port

    fn run[T: Route](self, route: T, _call: Int = 0) raises -> None:
        if not _call:
            self.__print_start[T](route=route)

        _ = self.__py_socket.listen()
        let connection: Connection = self.__accept_connection()
        connection.print_log_connect_message()
        while True:
            let st: Float64 = time.now()
            let response: Response = self.__handle_request[T](
                route=route, connection=connection, _call=_call
            )
            _ = connection.send_response(response)
            connection.close()
            let et: Float64 = time.now()

            # print additional response information
            response.print_log_message(execution_time=(et - st) / 1e9)

            # go back to listening for requests
            self.run[T](route=route, _call=_call + 1)

    fn __handle_request[
        T: Route
    ](self, route: T, connection: Connection, _call: Int) raises -> Response:
        let request_str = connection.recieve_data(size=1024)
        if not request_str:
            return Response(
                status_code=400,
                body="invalid request. Server was unable to recieve data.",
            )

        let request = Request.from_raw(request_str)
        if not request.is_valid():
            return Response(
                status_code=400,
                body="invalid request. client request was deemed invalid.",
            )

        let response: Response = route.func(request=request)
        return response
